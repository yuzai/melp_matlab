// -------------------------------------------------------------
//
// Module: filter_serial
// Generated by MATLAB(R) 9.1 and the Filter Design HDL Coder 3.1.
// Generated on: 2017-11-10 16:23:20
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Code Generation Options:
//
// FoldingFactor: 6
// TargetDirectory: /Users/xiaoboma/Documents/yanjiusheng/p5/biye/code/matlab´úÂë/test-matlab
// Name: filter_serial
// TargetLanguage: Verilog
// TestBenchStimulus: step ramp chirp 

// Filter Specifications:
//
// Sample Rate       : N/A (normalized frequency)
// Response          : Bandpass
// Specification     : N,F3dB1,F3dB2
// Filter Order      : 2
// Second 3-dB Point : 0.25
// First 3-dB Point  : 0.125
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Implementation    : Fully Serial
// Folding Factor        : 6
// -------------------------------------------------------------
// Filter Settings:
//
// Discrete-Time IIR Filter (real)
// -------------------------------
// Filter Structure    : Direct-Form II, Second-Order Sections
// Number of Sections  : 1
// Stable              : Yes
// Linear Phase        : No
// -------------------------------------------------------------




`timescale 1 ns / 1 ns

module filter_serial
               (
                clk,
                clk_enable,
                reset,
                filter_in,
                filter_out
                );

  input   clk; 
  input   clk_enable; 
  input   reset; 
  input   [63:0] filter_in; //double
  output  [63:0] filter_out; //double

////////////////////////////////////////////////////////////////
//Module Architecture: filter_serial
////////////////////////////////////////////////////////////////
  // Local Functions
  // Type Definitions
  // Constants
  parameter scaleconst1 = 1.6591068104035048E-01; //double
  parameter coeff_b1_section1 = 1.0000000000000000E+00; //double
  parameter coeff_b2_section1 = 0.0000000000000000E+00; //double
  parameter coeff_b3_section1 = -1.0000000000000000E+00; //double
  parameter coeff_a2_section1 = -1.4142135623730951E+00; //double
  parameter coeff_a3_section1 = 6.6817863791929910E-01; //double
  // Signals
  real input_register; // double
  reg  [2:0] cur_count; // ufix3
  wire phase_0; // boolean
  wire phase_2; // boolean
  wire phase_3; // boolean
  wire phase_5; // boolean
  real sectionipconvert; // double
  real storagetypeconvert; // double
  real storage_state_in1; // double
  real delay_section1 [0:1] ; // double
  real inputmux_section_1; // double
  real coeffmux_section_1; // double
  real prod; // double
  real prod_den; // double
  real prod_den_cast_temp; // double
  real prod_den_cast; // double
  real prod_den_cast_neg; // double
  real prod_num; // double
  real prod_num_cast_temp; // double
  real prod_num_cast; // double
  real accum_mux_in1; // double
  real accum_mux_in2; // double
  real accum_mux_out; // double
  real accum_mux_in1_temp; // double
  real sectionipconvert_cast; // double
  wire final_phase; // boolean
  wire section_phase; // boolean
  real accum_reg; // double
  real acc_out_cast_numacc; // double
  real output_typeconvert; // double
  real output_register; // double

  // Block Statements
  always @ (posedge clk or posedge reset)
    begin: input_reg_process
      if (reset == 1'b1) begin
        input_register <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          input_register <= $bitstoreal(filter_in);
        end
      end
    end // input_reg_process

  always @ (posedge clk or posedge reset)
    begin: Counter_process
      if (reset == 1'b1) begin
        cur_count <= 3'b000;
      end
      else begin
        if (clk_enable == 1'b1) begin
          if (cur_count == 3'b101) begin
            cur_count <= 3'b000;
          end
          else begin
            cur_count <= cur_count + 1;
          end
        end
      end
    end // Counter_process

  assign  phase_0 = (cur_count == 3'b000 && clk_enable == 1'b1)? 1 : 0;

  assign  phase_2 = (cur_count == 3'b010 && clk_enable == 1'b1)? 1 : 0;

  assign  phase_3 = (cur_count == 3'b011 && clk_enable == 1'b1)? 1 : 0;

  assign  phase_5 = (cur_count == 3'b101 && clk_enable == 1'b1)? 1 : 0;

  always @ (posedge clk or posedge reset)
    begin: delay_process_section1
      if (reset == 1'b1) begin
        delay_section1[0] <= 0.0000000000000000E+00;
        delay_section1[1] <= 0.0000000000000000E+00;
      end
      else begin
        if (phase_0 == 1'b1) begin
          delay_section1[1] <= delay_section1[0];
          delay_section1[0] <= storage_state_in1;
        end
      end
    end // delay_process_section1

  // Making common precision for input and state 
  always @* inputmux_section_1 <= (cur_count == 3'b000) ? input_register :
                             (cur_count == 3'b001) ? delay_section1[0] :
                             (cur_count == 3'b010) ? delay_section1[1] :
                             (cur_count == 3'b011) ? storage_state_in1 :
                             (cur_count == 3'b100) ? delay_section1[0] :
                             delay_section1[1];

  always @* coeffmux_section_1 <= (cur_count == 3'b000) ? scaleconst1 :
                             (cur_count == 3'b001) ? coeff_a2_section1 :
                             (cur_count == 3'b010) ? coeff_a3_section1 :
                             (cur_count == 3'b011) ? coeff_b1_section1 :
                             (cur_count == 3'b100) ? coeff_b2_section1 :
                             coeff_b3_section1;

  always @* prod <= inputmux_section_1 * coeffmux_section_1;

  always @* prod_den <= prod;


  always @* prod_den_cast_temp <= prod_den;


  always @* prod_den_cast <= prod_den_cast_temp;


  always @* prod_den_cast_neg <= -prod_den_cast;

  always @* prod_num <= prod;


  always @* prod_num_cast_temp <= prod_num;


  always @* prod_num_cast <= prod_num_cast_temp;


  always @* accum_mux_in1 <= (cur_count == 3'b000) ? prod_num_cast :
                        (cur_count == 3'b001) ? prod_den_cast_neg :
                        (cur_count == 3'b010) ? prod_den_cast_neg :
                        (cur_count == 3'b011) ? prod_num_cast :
                        (cur_count == 3'b100) ? prod_num_cast :
                        prod_num_cast;

  assign final_phase =  phase_0 | phase_3;

  assign section_phase =  phase_0;

  always @* accum_mux_in1_temp <= (section_phase == 1'b1) ? sectionipconvert_cast :
                             accum_mux_in1;

  always @* accum_mux_out <= (final_phase == 1'b1) ? accum_mux_in1_temp :
                        accum_mux_in2;

  always @ (posedge clk or posedge reset)
    begin: accumulator_reg_process
      if (reset == 1'b1) begin
        accum_reg <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          accum_reg <= accum_mux_out;
        end
      end
    end // accumulator_reg_process

  always @* accum_mux_in2 <= accum_reg + accum_mux_in1;

  always @* storagetypeconvert <= accum_mux_out;


  always @* sectionipconvert <= prod;


  always @* sectionipconvert_cast <= sectionipconvert;


  always @* acc_out_cast_numacc <= accum_mux_out;


  always @* output_typeconvert <= acc_out_cast_numacc;


  always @ (posedge clk or posedge reset)
    begin: storage_reg1_process
      if (reset == 1'b1) begin
        storage_state_in1 <= 0.0000000000000000E+00;
      end
      else begin
        if (phase_2 == 1'b1) begin
          storage_state_in1 <= storagetypeconvert;
        end
      end
    end // storage_reg1_process

  always @ (posedge clk or posedge reset)
    begin: Output_Register_process
      if (reset == 1'b1) begin
        output_register <= 0.0000000000000000E+00;
      end
      else begin
        if (phase_5 == 1'b1) begin
          output_register <= output_typeconvert;
        end
      end
    end // Output_Register_process

  // Assignment Statements
  assign filter_out = $realtobits(output_register);
endmodule  // filter_serial
